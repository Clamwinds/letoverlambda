{"version":3,"sources":["expression.js"],"names":[],"mappings":"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","file":"expression-compiled.js","sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {reservedWords} from \"./identifier\"\nimport {has} from \"./util\"\n\nconst pp = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6) return\n  let key = prop.key, name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  let kind = prop.kind || \"init\", other\n  if (has(propHash, name)) {\n    other = propHash[name]\n    let isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raise(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp.parseExpression = function(noIn, refShorthandDefaultPos) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos)\n  if (this.type === tt.comma) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp.parseMaybeAssign = function(noIn, refShorthandDefaultPos, afterLeftParse) {\n  if (this.type == tt._yield && this.inGenerator) return this.parseYield()\n\n  let failOnShorthandAssign\n  if (!refShorthandDefaultPos) {\n    refShorthandDefaultPos = {start: 0}\n    failOnShorthandAssign = true\n  } else {\n    failOnShorthandAssign = false\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  let left = this.parseMaybeConditional(noIn, refShorthandDefaultPos)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refShorthandDefaultPos.start = 0 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start)\n  }\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp.parseMaybeConditional = function(noIn, refShorthandDefaultPos) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprOps(noIn, refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  if (this.eat(tt.question)) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp.parseExprOps = function(noIn, refShorthandDefaultPos) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeUnary(refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  let prec = this.type.binop\n  if (Array.isArray(leftStartPos)){\n    if (this.options.locations && noIn === undefined) {\n      // shift arguments to left by one\n      noIn = minPrec\n      minPrec = leftStartLoc\n      // flatten leftStartPos\n      leftStartLoc = leftStartPos[1]\n      leftStartPos = leftStartPos[0]\n    }\n  }\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      let node = this.startNodeAt(leftStartPos, leftStartLoc)\n      node.left = left\n      node.operator = this.value\n      let op = this.type\n      this.next()\n      let startPos = this.start, startLoc = this.startLoc\n      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn)\n      this.finishNode(node, (op === tt.logicalOR || op === tt.logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\")\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp.parseMaybeUnary = function(refShorthandDefaultPos) {\n  if (this.type.prefix) {\n    let node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary()\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raise(node.start, \"Deleting local variable in strict mode\")\n    return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprSubscripts(refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  while (this.type.postfix && !this.canInsertSemicolon()) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.prefix = false\n    node.argument = expr\n    this.checkLVal(expr)\n    this.next()\n    expr = this.finishNode(node, \"UpdateExpression\")\n  }\n  return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp.parseExprSubscripts = function(refShorthandDefaultPos) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprAtom(refShorthandDefaultPos)\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr\n  return this.parseSubscripts(expr, startPos, startLoc)\n}\n\npp.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  if (Array.isArray(startPos)){\n    if (this.options.locations && noCalls === undefined) {\n      // shift arguments to left by one\n      noCalls = startLoc\n      // flatten startPos\n      startLoc = startPos[1]\n      startPos = startPos[0]\n    }\n  }\n  for (;;) {\n    if (this.eat(tt.dot)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseIdent(true)\n      node.computed = false\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (this.eat(tt.bracketL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseExpression()\n      node.computed = true\n      this.expect(tt.bracketR)\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this.eat(tt.parenL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.callee = base\n      node.arguments = this.parseExprList(tt.parenR, false)\n      base = this.finishNode(node, \"CallExpression\")\n    } else if (this.type === tt.backQuote) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.tag = base\n      node.quasi = this.parseTemplate()\n      base = this.finishNode(node, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp.parseExprAtom = function(refShorthandDefaultPos) {\n  let node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._this:\n  case tt._super:\n    let type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt._yield:\n    if (this.inGenerator) this.unexpected()\n\n  case tt.name:\n    let startPos = this.start, startLoc = this.startLoc\n    let id = this.parseIdent(this.type !== tt.name)\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow))\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])\n    return id\n\n  case tt.regexp:\n    let value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    return this.parseParenAndDistinguishExpression(canBeArrow)\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    // check whether this is array comprehension or regular array\n    if (this.options.ecmaVersion >= 7 && this.type === tt._for) {\n      return this.parseComprehension(node, false)\n    }\n    node.elements = this.parseExprList(tt.bracketR, true, true, refShorthandDefaultPos)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refShorthandDefaultPos)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseLiteral = function(value) {\n  let node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  let val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp.parseParenAndDistinguishExpression = function(canBeArrow) {\n  let startPos = this.start, startLoc = this.startLoc, val\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    if (this.options.ecmaVersion >= 7 && this.type === tt._for) {\n      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true)\n    }\n\n    let innerStartPos = this.start, innerStartLoc = this.startLoc\n    let exprList = [], first = true\n    let refShorthandDefaultPos = {start: 0}, spreadStart, innerParenStart\n    while (this.type !== tt.parenR) {\n      first ? first = false : this.expect(tt.comma)\n      if (this.type === tt.ellipsis) {\n        spreadStart = this.start\n        exprList.push(this.parseParenItem(this.parseRest()))\n        break\n      } else {\n        if (this.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this.start\n        }\n        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem))\n      }\n    }\n    let innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      if (innerParenStart) this.unexpected(innerParenStart)\n        return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start)\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    let par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp.parseParenItem = function(item) {\n  return item\n}\n\npp.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument\n// to be a `[]` or dot subscript expression, but not a call — at\n// least, not without wrapping it in parentheses. Thus, it uses the\n\nconst empty = []\n\npp.parseNew = function() {\n  let node = this.startNode()\n  let meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raise(node.property.start, \"The only valid meta property for new is new.target\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)\n  else node.arguments = empty\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp.parseTemplateElement = function() {\n  let elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp.parseTemplate = function() {\n  let node = this.startNode()\n  this.next()\n  node.expressions = []\n  let curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this.expect(tt.dollarBraceL)\n    node.expressions.push(this.parseExpression())\n    this.expect(tt.braceR)\n    node.quasis.push(curElt = this.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp.parseObj = function(isPattern, refShorthandDefaultPos) {\n  let node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let prop = this.startNode(), isGenerator, startPos, startLoc\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refShorthandDefaultPos) {\n        startPos = this.start\n        startLoc = this.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this.eat(tt.star)\n    }\n    this.parsePropertyName(prop)\n    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos)\n    this.checkPropClash(prop, propHash)\n    node.properties.push(this.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos) {\n  if (this.eat(tt.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos)\n      prop.kind = \"init\"\n    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n      if (isPattern) this.unexpected()\n      prop.kind = \"init\"\n      prop.method = true\n      prop.value = this.parseMethod(isGenerator)\n    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type != tt.comma && this.type != tt.braceR)) {\n      if (isGenerator || isPattern) this.unexpected()\n      prop.kind = prop.key.name\n      this.parsePropertyName(prop)\n      prop.value = this.parseMethod(false)\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      prop.kind = \"init\"\n      if (isPattern) {\n        if (this.isKeyword(prop.key.name) ||\n            (this.strict && (reservedWords.strictBind(prop.key.name) || reservedWords.strict(prop.key.name))) ||\n            (!this.options.allowReserved && this.isReservedWord(prop.key.name)))\n          this.raise(prop.key.start, \"Binding \" + prop.key.name)\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n      } else if (this.type === tt.eq && refShorthandDefaultPos) {\n        if (!refShorthandDefaultPos.start)\n          refShorthandDefaultPos.start = this.start\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n      } else {\n        prop.value = prop.key\n      }\n      prop.shorthand = true\n    } else this.unexpected()\n}\n\npp.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = (this.type === tt.num || this.type === tt.string) ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n}\n\n// Parse object or class method.\n\npp.parseMethod = function(isGenerator) {\n  let node = this.startNode()\n  this.initFunction(node)\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false)\n  let allowExpressionBody\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = isGenerator\n    allowExpressionBody = true\n  } else {\n    allowExpressionBody = false\n  }\n  this.parseFunctionBody(node, allowExpressionBody)\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp.parseArrowExpression = function(node, params) {\n  this.initFunction(node)\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp.parseFunctionBody = function(node, allowExpression) {\n  let isExpression = allowExpression && this.type !== tt.braceL\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    let oldInFunc = this.inFunction, oldInGen = this.inGenerator, oldLabels = this.labels\n    this.inFunction = true; this.inGenerator = node.generator; this.labels = []\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.inFunction = oldInFunc; this.inGenerator = oldInGen; this.labels = oldLabels\n  }\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {\n    let nameHash = {}, oldStrict = this.strict\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    for (let i = 0; i < node.params.length; i++)\n      this.checkLVal(node.params[i], true, nameHash)\n    this.strict = oldStrict\n  }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp.parseExprList = function(close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (allowTrailingComma && this.afterTrailingComma(close)) break\n    } else first = false\n\n    if (allowEmpty && this.type === tt.comma) {\n      elts.push(null)\n    } else {\n      if (this.type === tt.ellipsis)\n        elts.push(this.parseSpread(refShorthandDefaultPos))\n      else\n        elts.push(this.parseMaybeAssign(false, refShorthandDefaultPos))\n    }\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp.parseIdent = function(liberal) {\n  let node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal &&\n        ((!this.options.allowReserved && this.isReservedWord(this.value)) ||\n         (this.strict && reservedWords.strict(this.value)) &&\n         (this.options.ecmaVersion >= 6 ||\n          this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1)))\n      this.raise(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp.parseYield = function() {\n  let node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\n// Parses array and generator comprehensions.\n\npp.parseComprehension = function(node, isGenerator) {\n  node.blocks = []\n  while (this.type === tt._for) {\n    let block = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    block.left = this.parseBindingAtom()\n    this.checkLVal(block.left, true)\n    this.expectContextual(\"of\")\n    block.right = this.parseExpression()\n    this.expect(tt.parenR)\n    node.blocks.push(this.finishNode(block, \"ComprehensionBlock\"))\n  }\n  node.filter = this.eat(tt._if) ? this.parseParenExpression() : null\n  node.body = this.parseExpression()\n  this.expect(isGenerator ? tt.parenR : tt.bracketR)\n  node.generator = isGenerator\n  return this.finishNode(node, \"ComprehensionExpression\")\n}\n"]}