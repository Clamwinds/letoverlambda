{"version":3,"sources":["statement.js"],"names":[],"mappings":"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","file":"statement-compiled.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {lineBreak} from \"./whitespace\"\n\nconst pp = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp.parseTopLevel = function(node) {\n  let first = true\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    let stmt = this.parseStatement(true, true)\n    node.body.push(stmt)\n    if (first && this.isUseStrict(stmt)) this.setStrict(true)\n    first = false\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nconst loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp.parseStatement = function(declaration, topLevel) {\n  let starttype = this.type, node = this.startNode()\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._let: case tt._const: if (!declaration) this.unexpected() // NOTE: falls through to _var\n  case tt._var: return this.parseVarStatement(node, starttype)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    let maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp.parseBreakContinueStatement = function(node, keyword) {\n  let isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  for (var i = 0; i < this.labels.length; ++i) {\n    let lab = this.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  if (this.type === tt._var || this.type === tt._let || this.type === tt._const) {\n    let init = this.startNode(), varKind = this.type\n    this.next()\n    this.parseVar(init, true, varKind)\n    this.finishNode(init, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init.declarations.length === 1 &&\n        !(varKind !== tt._var && init.declarations[0].init))\n      return this.parseForIn(node, init)\n    return this.parseFor(node, init)\n  }\n  let refShorthandDefaultPos = {start: 0}\n  let init = this.parseExpression(true, refShorthandDefaultPos)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init)\n    this.checkLVal(init)\n    return this.parseForIn(node, init)\n  } else if (refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start)\n  }\n  return this.parseFor(node, init)\n}\n\npp.parseFunctionStatement = function(node) {\n  this.next()\n  return this.parseFunction(node, true)\n}\n\npp.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  node.consequent = this.parseStatement(false)\n  node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp.parseSwitchStatement = function(node) {\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  for (var cur, sawDefault; this.type != tt.braceR;) {\n    if (this.type === tt._case || this.type === tt._default) {\n      let isCase = this.type === tt._case\n      if (cur) this.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this.startNode())\n      cur.consequent = []\n      this.next()\n      if (isCase) {\n        cur.test = this.parseExpression()\n      } else {\n        if (sawDefault) this.raise(this.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this.expect(tt.colon)\n    } else {\n      if (!cur) this.unexpected()\n      cur.consequent.push(this.parseStatement(true))\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nconst empty = []\n\npp.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    let clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.checkLVal(clause.param, true)\n    this.expect(tt.parenR)\n    clause.guard = null\n    clause.body = this.parseBlock()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.guardedHandlers = empty\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp.parseLabeledStatement = function(node, maybeName, expr) {\n  for (let i = 0; i < this.labels.length; ++i)\n    if (this.labels[i].name === maybeName) this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  let kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  this.labels.push({name: maybeName, kind: kind})\n  node.body = this.parseStatement(true)\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp.parseBlock = function(allowStrict) {\n  let node = this.startNode(), first = true, oldStrict\n  node.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    let stmt = this.parseStatement(true)\n    node.body.push(stmt)\n    if (first && allowStrict && this.isUseStrict(stmt)) {\n      oldStrict = this.strict\n      this.setStrict(this.strict = true)\n    }\n    first = false\n  }\n  if (oldStrict === false) this.setStrict(false)\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp.parseForIn = function(node, init) {\n  let type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp.parseVar = function(node, isFor, kind) {\n  node.declarations = []\n  node.kind = kind.keyword\n  for (;;) {\n    let decl = this.startNode()\n    this.parseVarId(decl)\n    if (this.eat(tt.eq)) {\n      decl.init = this.parseMaybeAssign(isFor)\n    } else if (kind === tt._const && !(this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this.type === tt._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"))\n    if (!this.eat(tt.comma)) break\n  }\n  return node\n}\n\npp.parseVarId = function(decl) {\n  decl.id = this.parseBindingAtom()\n  this.checkLVal(decl.id, true)\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseFunction = function(node, isStatement, allowExpressionBody) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = this.eat(tt.star)\n  if (isStatement || this.type === tt.name)\n    node.id = this.parseIdent()\n  this.parseFunctionParams(node)\n  this.parseFunctionBody(node, allowExpressionBody)\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\npp.parseFunctionParams = function(node) {\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false)\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseClass = function(node, isStatement) {\n  this.next()\n  this.parseClassId(node, isStatement)\n  this.parseClassSuper(node)\n  let classBody = this.startNode()\n  let hadConstructor = false\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this.eat(tt.semi)) continue\n    let method = this.startNode()\n    let isGenerator = this.eat(tt.star)\n    let isMaybeStatic = this.type === tt.name && this.value === \"static\"\n    this.parsePropertyName(method)\n    method.static = isMaybeStatic && this.type !== tt.parenL\n    if (method.static) {\n      if (isGenerator) this.unexpected()\n      isGenerator = this.eat(tt.star)\n      this.parsePropertyName(method)\n    }\n    method.kind = \"method\"\n    if (!method.computed) {\n      let {key} = method\n      let isGetSet = false\n      if (!isGenerator && key.type === \"Identifier\" && this.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true\n        method.kind = key.name\n        key = this.parsePropertyName(method)\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this.raise(key.start, \"Duplicate constructor in the same class\")\n        if (isGetSet) this.raise(key.start, \"Constructor can't have get/set modifier\")\n        if (isGenerator) this.raise(key.start, \"Constructor can't be a generator\")\n        method.kind = \"constructor\"\n        hadConstructor = true\n      }\n    }\n    this.parseClassMethod(classBody, method, isGenerator)\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\npp.parseClassMethod = function(classBody, method, isGenerator) {\n  method.value = this.parseMethod(isGenerator)\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n}\n\npp.parseClassId = function(node, isStatement) {\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null\n}\n\npp.parseClassSuper = function(node) {\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n}\n\n// Parses module export declaration.\n\npp.parseExport = function(node) {\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    let expr = this.parseMaybeAssign()\n    let needsSemi = true\n    if (expr.type == \"FunctionExpression\" ||\n        expr.type == \"ClassExpression\") {\n      needsSemi = false\n      if (expr.id) {\n        expr.type = expr.type == \"FunctionExpression\"\n          ? \"FunctionDeclaration\"\n          : \"ClassDeclaration\"\n      }\n    }\n    node.declaration = expr\n    if (needsSemi) this.semicolon()\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers()\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\npp.shouldParseExportStatement = function() {\n  return this.type.keyword\n}\n\n// Parses a comma-separated list of module exports.\n\npp.parseExportSpecifiers = function() {\n  let nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let node = this.startNode()\n    node.local = this.parseIdent(this.type === tt._default)\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n    node.kind = \"\"\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp.parseImportSpecifiers = function() {\n  let nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    let node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    let node = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let node = this.startNode()\n    node.imported = this.parseIdent(true)\n    node.local = this.eatContextual(\"as\") ? this.parseIdent() : node.imported\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n"]}