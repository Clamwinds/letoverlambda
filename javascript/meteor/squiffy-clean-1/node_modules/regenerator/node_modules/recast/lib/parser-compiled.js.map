{"version":3,"sources":["parser.js"],"names":[],"mappings":";;AAAA,IAAI,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;AAC/B,IAAI,KAAK,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;AAC/B,IAAI,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC;AACzB,IAAI,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC;AACvB,IAAI,QAAQ,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC;AACzC,IAAI,OAAO,GAAG,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC;AACvC,IAAI,UAAU,GAAG,KAAK,CAAC,YAAY,CAAC,QAAQ,CAAC;AAC7C,IAAI,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC;AAC3C,IAAI,gBAAgB,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,SAAS,CAAC;AACtD,IAAI,UAAU,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,UAAU,CAAC;AAC/C,IAAI,cAAc,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC;AAClD,IAAI,IAAI,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;;AAE7B,OAAO,CAAC,KAAK,GAAG,SAAS,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE;AAC5C,WAAO,GAAG,gBAAgB,CAAC,OAAO,CAAC,CAAC;;AAEpC,QAAI,KAAK,GAAG,UAAU,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;;AAExC,QAAI,iBAAiB,GAAG,KAAK,CAAC,QAAQ,CAAC;AACnC,gBAAQ,EAAE,OAAO,CAAC,QAAQ;AAC1B,uBAAe,EAAE,KAAK;AACtB,eAAO,EAAE,KAAK;KACjB,CAAC,CAAC;;AAEH,QAAI,QAAQ,GAAG,EAAE,CAAC;AAClB,QAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,iBAAiB,EAAE;AACnD,WAAG,EAAE,IAAI;AACT,iBAAS,EAAE,IAAI;AACf,aAAK,EAAE,OAAO,CAAC,KAAK;AACpB,eAAO,EAAE,IAAI;AACb,iBAAS,EAAE,QAAQ;AACnB,gBAAQ,EAAE,OAAO,CAAC,QAAQ;AAC1B,mBAAW,EAAE,CAAC;AACd,kBAAU,EAAE,QAAQ;KACvB,CAAC,CAAC;;AAEH,WAAO,CAAC,GAAG,GAAG,OAAO,CAAC,GAAG,IAAI;AACzB,aAAK,EAAE,KAAK,CAAC,QAAQ,EAAE;AACvB,WAAG,EAAE,KAAK,CAAC,OAAO,EAAE;KACvB,CAAC;;AAEF,WAAO,CAAC,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC;AAC1B,WAAO,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC;;;;;;AAAC,AAMvB,QAAI,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AACrD,WAAO,CAAC,GAAG,CAAC,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC;AACzC,WAAO,CAAC,GAAG,CAAC,GAAG,GAAG,cAAc,CAAC,GAAG,CAAC;;AAErC,QAAI,OAAO,CAAC,QAAQ,EAAE;AAClB,gBAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;AAC5B,eAAO,OAAO,CAAC,QAAQ,CAAC;KAC3B;;;;AAAA,AAID,QAAI,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC3B,QAAI,CAAC,GAAG,GAAG;AACP,aAAK,EAAE,KAAK;AACZ,cAAM,EAAE,CAAC;AACT,aAAK,EAAE,KAAK,CAAC,QAAQ,EAAE;AACvB,WAAG,EAAE,KAAK,CAAC,OAAO,EAAE;KACvB;;;;AAAC,AAIF,kBAAc,CACV,QAAQ,EACR,OAAO,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,EACzC,KAAK,CACR;;;;AAAC,AAIF,WAAO,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;CAC3C,CAAC;;AAEF,SAAS,UAAU,CAAC,KAAK,EAAE;AACvB,UAAM,CAAC,EAAE,CAAC,IAAI,YAAY,UAAU,CAAC,CAAC;AACtC,QAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACnB,QAAI,CAAC,MAAM,GAAG,CAAC,CAAC;CACnB;;AAED,IAAI,GAAG,GAAG,UAAU,CAAC,SAAS,CAAC;;AAE/B,GAAG,CAAC,IAAI,GAAG,UAAS,IAAI,EAAE;AACtB,QAAI,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AACrB,eAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;KACpC;;AAED,QAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AACvB,eAAO,IAAI,CAAC;KACf;;AAED,QAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;;AAE9B,QAAI,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;AAClD,gBAAQ,EAAE;AACN,iBAAK,EAAE,IAAI;AACX,wBAAY,EAAE,KAAK;AACnB,sBAAU,EAAE,KAAK;AACjB,oBAAQ,EAAE,IAAI;SACjB;KACJ,CAAC,CAAC;;AAEH,QAAI,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;AACnB,QAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC;AAC5B,QAAI,SAAS,GAAG,SAAS,CAAC;;AAE1B,QAAI,GAAG,EAAE;;;;;;AAML,YAAI,IAAI,CAAC,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,IAC7C,IAAI,CAAC,KAAK,CAAC,0BAA0B,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;AAClD,qBAAS,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC;SAC9C;;AAED,WAAG,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACvB,WAAG,CAAC,MAAM,GAAG,SAAS,CAAC;KAC1B;;AAED,QAAI,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAI,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;AAC3B,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,EAAE,CAAC,EAAE;AAC/B,YAAI,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AAClB,YAAI,GAAG,KAAK,KAAK,EAAE;AACf,gBAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;SACzB,MAAM;AACH,gBAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;SACpC;KACJ;;AAED,QAAI,CAAC,MAAM,GAAG,SAAS,CAAC;;AAExB,WAAO,IAAI,CAAC;CACf,CAAC","file":"parser-compiled.js","sourcesContent":["var assert = require(\"assert\");\nvar types = require(\"./types\");\nvar n = types.namedTypes;\nvar b = types.builders;\nvar isObject = types.builtInTypes.object;\nvar isArray = types.builtInTypes.array;\nvar isFunction = types.builtInTypes.function;\nvar Patcher = require(\"./patcher\").Patcher;\nvar normalizeOptions = require(\"./options\").normalize;\nvar fromString = require(\"./lines\").fromString;\nvar attachComments = require(\"./comments\").attach;\nvar util = require(\"./util\");\n\nexports.parse = function parse(source, options) {\n    options = normalizeOptions(options);\n\n    var lines = fromString(source, options);\n\n    var sourceWithoutTabs = lines.toString({\n        tabWidth: options.tabWidth,\n        reuseWhitespace: false,\n        useTabs: false\n    });\n\n    var comments = [];\n    var program = options.esprima.parse(sourceWithoutTabs, {\n        loc: true,\n        locations: true,\n        range: options.range,\n        comment: true,\n        onComment: comments,\n        tolerant: options.tolerant,\n        ecmaVersion: 6,\n        sourceType: 'module'\n    });\n\n    program.loc = program.loc || {\n        start: lines.firstPos(),\n        end: lines.lastPos()\n    };\n\n    program.loc.lines = lines;\n    program.loc.indent = 0;\n\n    // Expand the Program node's .loc to include all comments, since\n    // typically its .loc.start and .loc.end will coincide with those of\n    // the first and last statements, respectively, excluding any comments\n    // that fall outside that region.\n    var trueProgramLoc = util.getTrueLoc(program, lines);\n    program.loc.start = trueProgramLoc.start;\n    program.loc.end = trueProgramLoc.end;\n\n    if (program.comments) {\n        comments = program.comments;\n        delete program.comments;\n    }\n\n    // In order to ensure we reprint leading and trailing program\n    // comments, wrap the original Program node with a File node.\n    var file = b.file(program);\n    file.loc = {\n        lines: lines,\n        indent: 0,\n        start: lines.firstPos(),\n        end: lines.lastPos()\n    };\n\n    // Passing file.program here instead of just file means that initial\n    // comments will be attached to program.body[0] instead of program.\n    attachComments(\n        comments,\n        program.body.length ? file.program : file,\n        lines\n    );\n\n    // Return a copy of the original AST so that any changes made may be\n    // compared to the original.\n    return new TreeCopier(lines).copy(file);\n};\n\nfunction TreeCopier(lines) {\n    assert.ok(this instanceof TreeCopier);\n    this.lines = lines;\n    this.indent = 0;\n}\n\nvar TCp = TreeCopier.prototype;\n\nTCp.copy = function(node) {\n    if (isArray.check(node)) {\n        return node.map(this.copy, this);\n    }\n\n    if (!isObject.check(node)) {\n        return node;\n    }\n\n    util.fixFaultyLocations(node);\n\n    var copy = Object.create(Object.getPrototypeOf(node), {\n        original: { // Provide a link from the copy to the original.\n            value: node,\n            configurable: false,\n            enumerable: false,\n            writable: true\n        }\n    });\n\n    var loc = node.loc;\n    var oldIndent = this.indent;\n    var newIndent = oldIndent;\n\n    if (loc) {\n        // When node is a comment, we set node.loc.indent to\n        // node.loc.start.column so that, when/if we print the comment by\n        // itself, we can strip that much whitespace from the left margin\n        // of the comment. This only really matters for multiline Block\n        // comments, but it doesn't hurt for Line comments.\n        if (node.type === \"Block\" || node.type === \"Line\" ||\n            this.lines.isPrecededOnlyByWhitespace(loc.start)) {\n            newIndent = this.indent = loc.start.column;\n        }\n\n        loc.lines = this.lines;\n        loc.indent = newIndent;\n    }\n\n    var keys = Object.keys(node);\n    var keyCount = keys.length;\n    for (var i = 0; i < keyCount; ++i) {\n        var key = keys[i];\n        if (key === \"loc\") {\n            copy[key] = node[key];\n        } else {\n            copy[key] = this.copy(node[key]);\n        }\n    }\n\n    this.indent = oldIndent;\n\n    return copy;\n};\n"]}