{"version":3,"sources":["patcher.js"],"names":[],"mappings":"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","file":"patcher-compiled.js","sourcesContent":["var assert = require(\"assert\");\nvar linesModule = require(\"./lines\");\nvar types = require(\"./types\");\nvar getFieldValue = types.getFieldValue;\nvar Printable = types.namedTypes.Printable;\nvar Expression = types.namedTypes.Expression;\nvar SourceLocation = types.namedTypes.SourceLocation;\nvar util = require(\"./util\");\nvar comparePos = util.comparePos;\nvar FastPath = require(\"./fast-path\");\nvar isObject = types.builtInTypes.object;\nvar isArray = types.builtInTypes.array;\nvar isString = types.builtInTypes.string;\nvar riskyAdjoiningCharExp = /[0-9a-z_$]/i;\n\nfunction Patcher(lines) {\n    assert.ok(this instanceof Patcher);\n    assert.ok(lines instanceof linesModule.Lines);\n\n    var self = this,\n        replacements = [];\n\n    self.replace = function(loc, lines) {\n        if (isString.check(lines))\n            lines = linesModule.fromString(lines);\n\n        replacements.push({\n            lines: lines,\n            start: loc.start,\n            end: loc.end\n        });\n    };\n\n    self.get = function(loc) {\n        // If no location is provided, return the complete Lines object.\n        loc = loc || {\n            start: { line: 1, column: 0 },\n            end: { line: lines.length,\n                   column: lines.getLineLength(lines.length) }\n        };\n\n        var sliceFrom = loc.start,\n            toConcat = [];\n\n        function pushSlice(from, to) {\n            assert.ok(comparePos(from, to) <= 0);\n            toConcat.push(lines.slice(from, to));\n        }\n\n        replacements.sort(function(a, b) {\n            return comparePos(a.start, b.start);\n        }).forEach(function(rep) {\n            if (comparePos(sliceFrom, rep.start) > 0) {\n                // Ignore nested replacement ranges.\n            } else {\n                pushSlice(sliceFrom, rep.start);\n                toConcat.push(rep.lines);\n                sliceFrom = rep.end;\n            }\n        });\n\n        pushSlice(sliceFrom, loc.end);\n\n        return linesModule.concat(toConcat);\n    };\n}\nexports.Patcher = Patcher;\n\nvar Pp = Patcher.prototype;\n\nPp.tryToReprintComments = function(newNode, oldNode, print) {\n    var patcher = this;\n\n    if (!newNode.comments &&\n        !oldNode.comments) {\n        // We were (vacuously) able to reprint all the comments!\n        return true;\n    }\n\n    var newPath = FastPath.from(newNode);\n    var oldPath = FastPath.from(oldNode);\n\n    newPath.stack.push(\"comments\", getSurroundingComments(newNode));\n    oldPath.stack.push(\"comments\", getSurroundingComments(oldNode));\n\n    var reprints = [];\n    var ableToReprintComments =\n        findArrayReprints(newPath, oldPath, reprints);\n\n    // No need to pop anything from newPath.stack or oldPath.stack, since\n    // newPath and oldPath are fresh local variables.\n\n    if (ableToReprintComments && reprints.length > 0) {\n        reprints.forEach(function(reprint) {\n            var oldComment = reprint.oldPath.getValue();\n            assert.ok(oldComment.leading || oldComment.trailing);\n            patcher.replace(\n                oldComment.loc,\n                // Comments can't have .comments, so it doesn't matter\n                // whether we print with comments or without.\n                print(reprint.newPath).indentTail(oldComment.loc.indent)\n            );\n        });\n    }\n\n    return ableToReprintComments;\n};\n\n// Get all comments that are either leading or trailing, ignoring any\n// comments that occur inside node.loc. Returns an empty array for nodes\n// with no leading or trailing comments.\nfunction getSurroundingComments(node) {\n    var result = [];\n    if (node.comments &&\n        node.comments.length > 0) {\n        node.comments.forEach(function(comment) {\n            if (comment.leading || comment.trailing) {\n                result.push(comment);\n            }\n        });\n    }\n    return result;\n}\n\nPp.deleteComments = function(node) {\n    if (!node.comments) {\n        return;\n    }\n\n    var patcher = this;\n\n    node.comments.forEach(function(comment) {\n        if (comment.leading) {\n            // Delete leading comments along with any trailing whitespace\n            // they might have.\n            patcher.replace({\n                start: comment.loc.start,\n                end: node.loc.lines.skipSpaces(\n                    comment.loc.end, false, false)\n            }, \"\");\n\n        } else if (comment.trailing) {\n            // Delete trailing comments along with any leading whitespace\n            // they might have.\n            patcher.replace({\n                start: node.loc.lines.skipSpaces(\n                    comment.loc.start, true, false),\n                end: comment.loc.end\n            }, \"\");\n        }\n    });\n};\n\nexports.getReprinter = function(path) {\n    assert.ok(path instanceof FastPath);\n\n    // Make sure that this path refers specifically to a Node, rather than\n    // some non-Node subproperty of a Node.\n    var node = path.getValue();\n    if (!Printable.check(node))\n        return;\n\n    var orig = node.original;\n    var origLoc = orig && orig.loc;\n    var lines = origLoc && origLoc.lines;\n    var reprints = [];\n\n    if (!lines || !findReprints(path, reprints))\n        return;\n\n    return function(print) {\n        var patcher = new Patcher(lines);\n\n        reprints.forEach(function(reprint) {\n            var newNode = reprint.newPath.getValue();\n            var oldNode = reprint.oldPath.getValue();\n\n            SourceLocation.assert(oldNode.loc, true);\n\n            var needToPrintNewPathWithComments =\n                !patcher.tryToReprintComments(newNode, oldNode, print)\n\n            if (needToPrintNewPathWithComments) {\n                // Since we were not able to preserve all leading/trailing\n                // comments, we delete oldNode's comments, print newPath\n                // with comments, and then patch the resulting lines where\n                // oldNode used to be.\n                patcher.deleteComments(oldNode);\n            }\n\n            var pos = util.copyPos(oldNode.loc.start);\n            var needsLeadingSpace = lines.prevPos(pos) &&\n                riskyAdjoiningCharExp.test(lines.charAt(pos));\n\n            var newLines = print(\n                reprint.newPath,\n                needToPrintNewPathWithComments\n            ).indentTail(oldNode.loc.indent);\n\n            var needsTrailingSpace =\n                riskyAdjoiningCharExp.test(lines.charAt(oldNode.loc.end));\n\n            // If we try to replace the argument of a ReturnStatement like\n            // return\"asdf\" with e.g. a literal null expression, we run\n            // the risk of ending up with returnnull, so we need to add an\n            // extra leading space in situations where that might\n            // happen. Likewise for \"asdf\"in obj. See #170.\n            if (needsLeadingSpace || needsTrailingSpace) {\n                var newParts = [];\n                needsLeadingSpace && newParts.push(\" \");\n                newParts.push(newLines);\n                needsTrailingSpace && newParts.push(\" \");\n                newLines = linesModule.concat(newParts);\n            }\n\n            patcher.replace(oldNode.loc, newLines);\n        });\n\n        // Recall that origLoc is the .loc of an ancestor node that is\n        // guaranteed to contain all the reprinted nodes and comments.\n        return patcher.get(origLoc).indentTail(-orig.loc.indent);\n    };\n};\n\nfunction findReprints(newPath, reprints) {\n    var newNode = newPath.getValue();\n    Printable.assert(newNode);\n\n    var oldNode = newNode.original;\n    Printable.assert(oldNode);\n\n    assert.deepEqual(reprints, []);\n\n    if (newNode.type !== oldNode.type) {\n        return false;\n    }\n\n    var oldPath = new FastPath(oldNode);\n    var canReprint = findChildReprints(newPath, oldPath, reprints);\n\n    if (!canReprint) {\n        // Make absolutely sure the calling code does not attempt to reprint\n        // any nodes.\n        reprints.length = 0;\n    }\n\n    return canReprint;\n}\n\nfunction findAnyReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n\n    if (newNode === oldNode)\n        return true;\n\n    if (isArray.check(newNode))\n        return findArrayReprints(newPath, oldPath, reprints);\n\n    if (isObject.check(newNode))\n        return findObjectReprints(newPath, oldPath, reprints);\n\n    return false;\n}\n\nfunction findArrayReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    isArray.assert(newNode);\n    var len = newNode.length;\n\n    if (!(isArray.check(oldNode) &&\n          oldNode.length === len))\n        return false;\n\n    for (var i = 0; i < len; ++i) {\n        newPath.stack.push(i, newNode[i]);\n        oldPath.stack.push(i, oldNode[i]);\n        var canReprint = findAnyReprints(newPath, oldPath, reprints);\n        newPath.stack.length -= 2;\n        oldPath.stack.length -= 2;\n        if (!canReprint) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction findObjectReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    isObject.assert(newNode);\n\n    if (newNode.original === null) {\n        // If newNode.original node was set to null, reprint the node.\n        return false;\n    }\n\n    var oldNode = oldPath.getValue();\n    if (!isObject.check(oldNode))\n        return false;\n\n    if (Printable.check(newNode)) {\n        if (!Printable.check(oldNode)) {\n            return false;\n        }\n\n        // Here we need to decide whether the reprinted code for newNode\n        // is appropriate for patching into the location of oldNode.\n\n        if (newNode.type === oldNode.type) {\n            var childReprints = [];\n\n            if (findChildReprints(newPath, oldPath, childReprints)) {\n                reprints.push.apply(reprints, childReprints);\n            } else if (oldNode.loc) {\n                // If we have no .loc information for oldNode, then we\n                // won't be able to reprint it.\n                reprints.push({\n                    oldPath: oldPath.copy(),\n                    newPath: newPath.copy()\n                });\n            } else {\n                return false;\n            }\n\n            return true;\n        }\n\n        if (Expression.check(newNode) &&\n            Expression.check(oldNode) &&\n            // If we have no .loc information for oldNode, then we won't\n            // be able to reprint it.\n            oldNode.loc) {\n\n            // If both nodes are subtypes of Expression, then we should be\n            // able to fill the location occupied by the old node with\n            // code printed for the new node with no ill consequences.\n            reprints.push({\n                oldPath: oldPath.copy(),\n                newPath: newPath.copy()\n            });\n\n            return true;\n        }\n\n        // The nodes have different types, and at least one of the types\n        // is not a subtype of the Expression type, so we cannot safely\n        // assume the nodes are syntactically interchangeable.\n        return false;\n    }\n\n    return findChildReprints(newPath, oldPath, reprints);\n}\n\n// This object is reused in hasOpeningParen and hasClosingParen to avoid\n// having to allocate a temporary object.\nvar reusablePos = { line: 1, column: 0 };\nvar nonSpaceExp = /\\S/;\n\nfunction hasOpeningParen(oldPath) {\n    var oldNode = oldPath.getValue();\n    var loc = oldNode.loc;\n    var lines = loc && loc.lines;\n\n    if (lines) {\n        var pos = reusablePos;\n        pos.line = loc.start.line;\n        pos.column = loc.start.column;\n\n        while (lines.prevPos(pos)) {\n            var ch = lines.charAt(pos);\n\n            if (ch === \"(\") {\n                // If we found an opening parenthesis but it occurred before\n                // the start of the original subtree for this reprinting, then\n                // we must not return true for hasOpeningParen(oldPath).\n                return comparePos(oldPath.getRootValue().loc.start, pos) <= 0;\n            }\n\n            if (nonSpaceExp.test(ch)) {\n                return false;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction hasClosingParen(oldPath) {\n    var oldNode = oldPath.getValue();\n    var loc = oldNode.loc;\n    var lines = loc && loc.lines;\n\n    if (lines) {\n        var pos = reusablePos;\n        pos.line = loc.end.line;\n        pos.column = loc.end.column;\n\n        do {\n            var ch = lines.charAt(pos);\n\n            if (ch === \")\") {\n                // If we found a closing parenthesis but it occurred after the\n                // end of the original subtree for this reprinting, then we\n                // must not return true for hasClosingParen(oldPath).\n                return comparePos(pos, oldPath.getRootValue().loc.end) <= 0;\n            }\n\n            if (nonSpaceExp.test(ch)) {\n                return false;\n            }\n\n        } while (lines.nextPos(pos));\n    }\n\n    return false;\n}\n\nfunction hasParens(oldPath) {\n    // This logic can technically be fooled if the node has parentheses\n    // but there are comments intervening between the parentheses and the\n    // node. In such cases the node will be harmlessly wrapped in an\n    // additional layer of parentheses.\n    return hasOpeningParen(oldPath) && hasClosingParen(oldPath);\n}\n\nfunction findChildReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n\n    isObject.assert(newNode);\n    isObject.assert(oldNode);\n\n    if (newNode.original === null) {\n        // If newNode.original node was set to null, reprint the node.\n        return false;\n    }\n\n    // If this type of node cannot come lexically first in its enclosing\n    // statement (e.g. a function expression or object literal), and it\n    // seems to be doing so, then the only way we can ignore this problem\n    // and save ourselves from falling back to the pretty printer is if an\n    // opening parenthesis happens to precede the node.  For example,\n    // (function(){ ... }()); does not need to be reprinted, even though\n    // the FunctionExpression comes lexically first in the enclosing\n    // ExpressionStatement and fails the hasParens test, because the\n    // parent CallExpression passes the hasParens test. If we relied on\n    // the path.needsParens() && !hasParens(oldNode) check below, the\n    // absence of a closing parenthesis after the FunctionExpression would\n    // trigger pretty-printing unnecessarily.\n    if (!newPath.canBeFirstInStatement() &&\n        newPath.firstInStatement() &&\n        !hasOpeningParen(oldPath))\n        return false;\n\n    // If this node needs parentheses and will not be wrapped with\n    // parentheses when reprinted, then return false to skip reprinting\n    // and let it be printed generically.\n    if (newPath.needsParens(true) && !hasParens(oldPath)) {\n        return false;\n    }\n\n    for (var k in util.getUnionOfKeys(newNode, oldNode)) {\n        if (k === \"loc\")\n            continue;\n\n        newPath.stack.push(k, types.getFieldValue(newNode, k));\n        oldPath.stack.push(k, types.getFieldValue(oldNode, k));\n        var canReprint = findAnyReprints(newPath, oldPath, reprints);\n        newPath.stack.length -= 2;\n        oldPath.stack.length -= 2;\n\n        if (!canReprint) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"]}