{"version":3,"sources":["util.js"],"names":[],"mappings":"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","file":"util-compiled.js","sourcesContent":["var assert = require(\"assert\");\nvar types = require(\"./types\");\nvar getFieldValue = types.getFieldValue;\nvar n = types.namedTypes;\nvar sourceMap = require(\"source-map\");\nvar SourceMapConsumer = sourceMap.SourceMapConsumer;\nvar SourceMapGenerator = sourceMap.SourceMapGenerator;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction getUnionOfKeys() {\n    var result = {};\n    var argc = arguments.length;\n    for (var i = 0; i < argc; ++i) {\n        var keys = Object.keys(arguments[i]);\n        var keyCount = keys.length;\n        for (var j = 0; j < keyCount; ++j) {\n            result[keys[j]] = true;\n        }\n    }\n    return result;\n}\nexports.getUnionOfKeys = getUnionOfKeys;\n\nfunction comparePos(pos1, pos2) {\n    return (pos1.line - pos2.line) || (pos1.column - pos2.column);\n}\nexports.comparePos = comparePos;\n\nfunction copyPos(pos) {\n    return {\n        line: pos.line,\n        column: pos.column\n    };\n}\nexports.copyPos = copyPos;\n\nexports.composeSourceMaps = function(formerMap, latterMap) {\n    if (formerMap) {\n        if (!latterMap) {\n            return formerMap;\n        }\n    } else {\n        return latterMap || null;\n    }\n\n    var smcFormer = new SourceMapConsumer(formerMap);\n    var smcLatter = new SourceMapConsumer(latterMap);\n    var smg = new SourceMapGenerator({\n        file: latterMap.file,\n        sourceRoot: latterMap.sourceRoot\n    });\n\n    var sourcesToContents = {};\n\n    smcLatter.eachMapping(function(mapping) {\n        var origPos = smcFormer.originalPositionFor({\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n        });\n\n        var sourceName = origPos.source;\n        if (sourceName === null) {\n            return;\n        }\n\n        smg.addMapping({\n            source: sourceName,\n            original: copyPos(origPos),\n            generated: {\n                line: mapping.generatedLine,\n                column: mapping.generatedColumn\n            },\n            name: mapping.name\n        });\n\n        var sourceContent = smcFormer.sourceContentFor(sourceName);\n        if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {\n            sourcesToContents[sourceName] = sourceContent;\n            smg.setSourceContent(sourceName, sourceContent);\n        }\n    });\n\n    return smg.toJSON();\n};\n\nexports.getTrueLoc = function(node, lines) {\n    // It's possible that node is newly-created (not parsed by Esprima),\n    // in which case it probably won't have a .loc property (or an\n    // .original property for that matter). That's fine; we'll just\n    // pretty-print it as usual.\n    if (!node.loc) {\n        return null;\n    }\n\n    var start = node.loc.start;\n    var end = node.loc.end;\n\n    // If the node has any comments, their locations might contribute to\n    // the true start/end positions of the node.\n    if (node.comments) {\n        node.comments.forEach(function(comment) {\n            if (comment.loc) {\n                if (comparePos(comment.loc.start, start) < 0) {\n                    start = comment.loc.start;\n                }\n\n                if (comparePos(end, comment.loc.end) < 0) {\n                    end = comment.loc.end;\n                }\n            }\n        });\n    }\n\n    return {\n        // Finally, trim any leading or trailing whitespace from the true\n        // location of the node.\n        start: lines.skipSpaces(start, false, false),\n        end: lines.skipSpaces(end, true, false)\n    };\n};\n\nexports.fixFaultyLocations = function(node) {\n    if ((n.MethodDefinition && n.MethodDefinition.check(node)) ||\n        (n.Property.check(node) && (node.method || node.shorthand))) {\n        // If the node is a MethodDefinition or a .method or .shorthand\n        // Property, then the location information stored in\n        // node.value.loc is very likely untrustworthy (just the {body}\n        // part of a method, or nothing in the case of shorthand\n        // properties), so we null out that information to prevent\n        // accidental reuse of bogus source code during reprinting.\n        node.value.loc = null;\n\n        if (n.FunctionExpression.check(node.value)) {\n            // FunctionExpression method values should be anonymous,\n            // because their .id fields are ignored anyway.\n            node.value.id = null;\n        }\n    }\n\n    var loc = node.loc;\n    if (loc) {\n        if (loc.start.line < 1) {\n            loc.start.line = 1;\n        }\n\n        if (loc.end.line < 1) {\n            loc.end.line = 1;\n        }\n    }\n};\n"]}