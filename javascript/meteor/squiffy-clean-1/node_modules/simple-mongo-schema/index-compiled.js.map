{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["\"use strict\";\n\n\nvar _typeToStr = function(typeClass) {\n  return typeClass.toString().match(/function\\s(.*)\\(/)[1];\n};\n\n\n/**\n * A schema.\n */\nvar Schema = function(schema) {\n  if (!schema) {\n    throw new Error('Schema is empty');\n  }\n\n  this.schema = schema;  \n}\n\n/**\n * Validate an object against this schema.\n * @param {Object} obj Object to validate.\n * @param {Object} [options] Additional options.\n * @param {Boolean} [options.ignoreMissing] Whether to ignore missing keys.\n * @throws {Error} If validation fails. The `details` field is an `Array` containing error messages.\n */\nSchema.prototype.validate = function*(obj, options) {\n  if (!obj) {\n    throw new Error('Object is empty');\n  }\n\n  options = options || {};\n  options.ignoreMissing = options.ignoreMissing || false;\n\n  var failures = [];\n  \n  yield this._doValidate({\n    failures: failures,\n    schema: {\n      path: '',\n      node: this.schema,\n    },\n    object: obj,\n  }, options);\n\n  if (failures.length) {\n    var e = new Error('Validation failed');\n\n    e.failures = failures.map(function(e) {\n      return e[0] + ': ' + e[1];\n    });\n\n    throw e;\n  }    \n}\n\n\n/**\n * Validate given object node against given schema node.\n */\nSchema.prototype._doValidate = function*(params, options) {\n  var schemaPath = params.schema.path, \n    schemaNode = params.schema.node,\n    obj = params.object,\n    failures = params.failures;\n\n  var self = this;\n\n  for (var key in schemaNode) {\n    var currentPath = schemaPath + '/' + key,\n      currentNode = schemaNode[key],\n      objectNode = obj[key],\n      currentNodeType = currentNode.type,\n      currentNodeValidators = currentNode.validate || [];\n\n    // if type not set\n    if (!currentNodeType) {\n      failures.push([currentPath, 'invalid schema']);\n      continue;\n    }\n\n    // missing?\n    if (undefined === objectNode) {\n      if (currentNode.required && !options.ignoreMissing) {\n        failures.push([currentPath, 'missing value']);\n      }\n\n      continue;\n    }\n\n    switch (currentNodeType) {\n      case String:\n        if ('string' !== typeof objectNode) {\n          failures.push([currentPath, 'must be a string']);\n        } else {\n          if (Array.isArray(currentNode.enum)) {\n            if (0 > currentNode.enum.indexOf(objectNode)) {\n              failures.push(\n                [currentPath, 'must be one of ' + currentNode.enum.join(', ')]\n              );\n            }\n          }\n        }\n        break;\n      case Boolean:\n        if ('boolean' !== typeof objectNode) {\n          failures.push([currentPath, 'must be true or false']);\n        }\n        break;\n      case Number:\n        if ('number' !== typeof objectNode) {\n          failures.push([currentPath, 'must be a number']);\n        }\n        break;\n      case Date:\n      case Object:\n      case Array:\n        if (!(objectNode instanceof currentNodeType)) {\n          failures.push([currentPath, 'must be of type ' + _typeToStr(currentNodeType)]);\n        }\n        break;\n      default:\n        // if value should be an array\n        if (Array.isArray(currentNodeType)) {\n          if (!Array.isArray(objectNode)) {\n            failures.push([currentPath, 'must be an array']);\n          } else {\n            var subSchema = currentNodeType[0];\n\n            for (var index in objectNode) {\n              var item = objectNode[index];\n\n              yield self._doValidate({\n                failures: failures,\n                schema: {\n                  path: currentPath + '/' + index,\n                  node: subSchema,\n                },\n                object: item,\n              }, options);\n            }\n          }\n        }\n        // else it just be an object\n        else {\n          yield self._doValidate({\n            failures: failures,\n            schema: {\n              path: currentPath,\n              node: currentNodeType,\n            },\n            object: objectNode,\n          }, options);\n        }\n    }\n\n    // custom validators\n    for (let i in currentNodeValidators) {\n      let fn = currentNodeValidators[i];\n\n      try {\n        yield fn(objectNode);\n      } catch (err) {\n        failures.push([currentPath, err.message]);\n      }\n    }\n  }\n}\n\n\n\n\n/**\n * Helper to typeify()\n */\nSchema.prototype._doTypeify = function(params) {\n  var self = this;\n\n  var schemaPath = params.schema.path, \n    schemaNode = params.schema.node,\n    object = params.object,\n    result = params.result;\n\n\n  for (var key in schemaNode) {\n    var currentPath = schemaPath + '/' + key,\n      currentNode = schemaNode[key],\n      objectNode = object[key],\n      currentNodeType = currentNode.type;\n\n    // console.log(currentPath, currentNodeType.toString(), key, objectNode, result);\n\n    // if type not set\n    if (!currentNodeType) {\n      continue;\n    }\n\n    // missing?\n    if (undefined === objectNode) {\n      continue;\n    }\n\n    // null?\n    if (null === objectNode) {\n      result[key] = objectNode;\n      continue;\n    }\n\n    try {\n      switch (currentNodeType) {\n        case String:\n          if ('string' !== typeof objectNode) {\n            objectNode = '' + objectNode;\n          }\n          break;\n        case Boolean:\n          if ('boolean' !== typeof objectNode) {\n            var tmp = ('' + objectNode).toLowerCase();\n\n            if ('false' === tmp || '0' === tmp || 'no' === tmp) {\n              objectNode = false;\n            } else if ('true' === tmp || '1' === tmp || 'yes' === tmp) {\n              objectNode = true;\n            }\n          }\n          break;\n        case Number:\n          if ('number' !== typeof objectNode) {\n            var tmp = '' + objectNode;\n\n            tmp = (0 <= tmp.indexOf('.')) \n              ? parseFloat(tmp) \n              : parseInt(tmp);\n\n            if (!Number.isNaN(tmp)) {\n              objectNode = tmp;\n            }\n          }\n          break;\n        case Date:\n          if (!(objectNode instanceof Date)) {\n            try {\n              var tmp = new Date(objectNode);\n              \n              if (0 < tmp) {\n                objectNode = tmp;\n              }\n            } catch (err) {\n              // do nothing\n            }\n          }\n          break;\n        case Object:\n        case Array:\n          // not much we can do here\n        default:\n          // if value should be an array\n          if (Array.isArray(currentNodeType)) {\n            if (Array.isArray(objectNode)) {\n              var subSchema = currentNodeType[0];\n\n              for (var index in objectNode) {\n                var item = objectNode[index];\n\n                self._doTypeify({\n                  schema: {\n                    path: currentPath + '/' + index,\n                    node: subSchema,\n                  },\n                  object: item,\n                  result: item,\n                });\n              }\n            }\n          }\n          // else it just be an object\n          else {\n            self._doTypeify({\n              schema: {\n                path: currentPath,\n                node: currentNodeType,\n              },\n              object: objectNode,\n              result: objectNode,\n            });\n          }\n      }\n    } catch (err) {\n      // do nothing\n    } \n\n    // set final result\n    result[key] = objectNode;\n  }\n}\n\n\n\n\n/**\n * Decode the correct type for given object's properties based on this schema.\n *\n * This will iterate through the object's properties. If a property path is \n * present in the schema then it will attempt to modify the property's value \n * such that its runtime type matches what the schema expects for that property.\n *\n * This method is useful if you have parsed JSON data which you wish to insert, \n * but in the case where all the property values are strings and the schema \n * expects some of them to be booleans, dates, etc. \n *\n * Any properties in the object which are not present in the schema are left \n * unchanged. And any schema properties not present in the object are ignored.\n * \n * @param {Object} obj Object to typeify.\n * @return {Object} Copy of the original object with new property values.\n */\nSchema.prototype.typeify = function(obj) {\n  if (!obj) {\n    return obj;\n  }\n\n  var newObj = {};\n\n  this._doTypeify({\n    schema: {\n      path: '',\n      node: this.schema,\n    },\n    object: obj,\n    result: newObj,\n  });\n\n  return newObj;\n}\n\n\n\n\nmodule.exports = function(schema) {\n  return new Schema(schema);\n};\n\n\nexports.Schema = Schema;\n\n\n\n"]}