{"version":3,"sources":["stable.js"],"names":[],"mappings":"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","file":"stable-compiled.js","sourcesContent":["//! stable.js 0.1.5, https://github.com/Two-Screen/stable\n//! Â© 2014 Angry Bytes and contributors. MIT licensed.\n\n(function() {\n\n// A stable array sort, because `Array#sort()` is not guaranteed stable.\n// This is an implementation of merge sort, without recursion.\n\nvar stable = function(arr, comp) {\n    return exec(arr.slice(), comp);\n};\n\nstable.inplace = function(arr, comp) {\n    var result = exec(arr, comp);\n\n    // This simply copies back if the result isn't in the original array,\n    // which happens on an odd number of passes.\n    if (result !== arr) {\n        pass(result, null, arr.length, arr);\n    }\n\n    return arr;\n};\n\n// Execute the sort using the input array and a second buffer as work space.\n// Returns one of those two, containing the final result.\nfunction exec(arr, comp) {\n    if (typeof(comp) !== 'function') {\n        comp = function(a, b) {\n            return String(a).localeCompare(b);\n        };\n    }\n\n    // Short-circuit when there's nothing to sort.\n    var len = arr.length;\n    if (len <= 1) {\n        return arr;\n    }\n\n    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\n    // Chunks are the size of the left or right hand in merge sort.\n    // Stop when the left-hand covers all of the array.\n    var buffer = new Array(len);\n    for (var chk = 1; chk < len; chk *= 2) {\n        pass(arr, comp, chk, buffer);\n\n        var tmp = arr;\n        arr = buffer;\n        buffer = tmp;\n    }\n\n    return arr;\n}\n\n// Run a single pass with the given chunk size.\nvar pass = function(arr, comp, chk, result) {\n    var len = arr.length;\n    var i = 0;\n    // Step size / double chunk size.\n    var dbl = chk * 2;\n    // Bounds of the left and right chunks.\n    var l, r, e;\n    // Iterators over the left and right chunk.\n    var li, ri;\n\n    // Iterate over pairs of chunks.\n    for (l = 0; l < len; l += dbl) {\n        r = l + chk;\n        e = r + chk;\n        if (r > len) r = len;\n        if (e > len) e = len;\n\n        // Iterate both chunks in parallel.\n        li = l;\n        ri = r;\n        while (true) {\n            // Compare the chunks.\n            if (li < r && ri < e) {\n                // This works for a regular `sort()` compatible comparator,\n                // but also for a simple comparator like: `a > b`\n                if (comp(arr[li], arr[ri]) <= 0) {\n                    result[i++] = arr[li++];\n                }\n                else {\n                    result[i++] = arr[ri++];\n                }\n            }\n            // Nothing to compare, just flush what's left.\n            else if (li < r) {\n                result[i++] = arr[li++];\n            }\n            else if (ri < e) {\n                result[i++] = arr[ri++];\n            }\n            // Both iterators are at the chunk ends.\n            else {\n                break;\n            }\n        }\n    }\n};\n\n// Export using CommonJS or to the window.\nif (typeof(module) !== 'undefined') {\n    module.exports = stable;\n}\nelse {\n    window.stable = stable;\n}\n\n})();\n"]}