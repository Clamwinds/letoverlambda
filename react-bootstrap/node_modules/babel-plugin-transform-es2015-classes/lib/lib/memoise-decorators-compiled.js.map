{"version":3,"sources":["memoise-decorators.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;AAEb,IAAI,YAAY,GAAG,OAAO,CAAC,oCAAoC,CAAC,CAAC,SAAS,CAAC,CAAC;;AAE5E,IAAI,uBAAuB,GAAG,OAAO,CAAC,gDAAgD,CAAC,CAAC,SAAS,CAAC,CAAC;;AAEnG,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;;AAE1B,IAAI,WAAW,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;;AAEzC,IAAI,CAAC,GAAG,uBAAuB,CAAC,WAAW,CAAC;;;AAAC,AAG7C,OAAO,CAAC,SAAS,CAAC,GAAG,UAAU,8BAAU,EAAsB,iBAAK,qBAAkC;AACpG,OAAK,IAAI,SAAS,GAAG,UAAU,EAAE,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,SAAS,GAAG,QAAQ,GAAG,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC,IAAI;AAC1I,QAAI,IAAI,CAAC;;AAET,QAAI,QAAQ,EAAE;AACZ,UAAI,EAAE,IAAI,SAAS,CAAC,MAAM,EAAE,MAAM;AAClC,UAAI,GAAG,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC;KACxB,MAAM;AACL,QAAE,GAAG,SAAS,CAAC,IAAI,EAAE,CAAC;AACtB,UAAI,EAAE,CAAC,IAAI,EAAE,MAAM;AACnB,UAAI,GAAG,EAAE,CAAC,KAAK,CAAC;KACjB;;AAED,QAAI,SAAS,GAAG,IAAI,CAAC;;AAErB,QAAI,UAAU,GAAG,SAAS,CAAC,UAAU,CAAC;AACtC,QAAI,CAAC,CAAC,CAAC,kBAAkB,CAAC,UAAU,CAAC,EAAE,SAAS;;AAEhD,QAAI,IAAI,GAAG,KAAK,CAAC,qBAAqB,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AAC1D,QAAI,GAAG,GAAG,SAAS,CAAC;;AAEpB,QAAI,KAAK,GAAG,EAAE,CAAC;;AAEf,QAAI,IAAI,EAAE;AACR,SAAG,GAAG,IAAI,CAAC;AACX,WAAK,CAAC,IAAI,CAAC,CAAC,CAAC,oBAAoB,CAAC,GAAG,EAAE,IAAI,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;KAClE,MAAM;AACL,SAAG,GAAG,UAAU,CAAC,MAAM,CAAC;KACzB;;AAED,SAAK,CAAC,IAAI,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,gBAAgB,CAAC,GAAG,EAAE,UAAU,CAAC,QAAQ,EAAE,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;AAEjJ,QAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;AACtB,eAAS,CAAC,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;KACjC,MAAM;AACL,eAAS,CAAC,UAAU,GAAG,CAAC,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;KACpD;GACF;;AAED,SAAO,UAAU,CAAC;CACnB,CAAC;;AAEF,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC","file":"memoise-decorators-compiled.js","sourcesContent":["\"use strict\";\n\nvar _getIterator = require(\"babel-runtime/core-js/get-iterator\")[\"default\"];\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nexports.__esModule = true;\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\n/*:: import type { Scope } from \"babel-traverse\";*/\nexports[\"default\"] = function (decorators /*: Array<Object>*/, scope /*: Scope*/) /*: Array<Object>*/ {\n  for (var _iterator = decorators, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var decorator = _ref;\n\n    var expression = decorator.expression;\n    if (!t.isMemberExpression(expression)) continue;\n\n    var temp = scope.maybeGenerateMemoised(expression.object);\n    var ref = undefined;\n\n    var nodes = [];\n\n    if (temp) {\n      ref = temp;\n      nodes.push(t.assignmentExpression(\"=\", temp, expression.object));\n    } else {\n      ref = expression.object;\n    }\n\n    nodes.push(t.callExpression(t.memberExpression(t.memberExpression(ref, expression.property, expression.computed), t.identifier(\"bind\")), [ref]));\n\n    if (nodes.length === 1) {\n      decorator.expression = nodes[0];\n    } else {\n      decorator.expression = t.sequenceExpression(nodes);\n    }\n  }\n\n  return decorators;\n};\n\nmodule.exports = exports[\"default\"];"]}