{"version":3,"sources":["comments.js"],"names":[],"mappings":"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","file":"comments-compiled.js","sourcesContent":["var assert = require(\"assert\");\nvar types = require(\"./types\");\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isObject = types.builtInTypes.object;\nvar linesModule = require(\"./lines\");\nvar fromString = linesModule.fromString;\nvar Lines = linesModule.Lines;\nvar concat = linesModule.concat;\nvar util = require(\"./util\");\nvar comparePos = util.comparePos;\nvar childNodesCacheKey = require(\"private\").makeUniqueKey();\n\n// TODO Move a non-caching implementation of this function into ast-types,\n// and implement a caching wrapper function here.\nfunction getSortedChildNodes(node, lines, resultArray) {\n    if (!node) {\n        return;\n    }\n\n    // The .loc checks below are sensitive to some of the problems that\n    // are fixed by this utility function. Specifically, if it decides to\n    // set node.loc to null, indicating that the node's .loc information\n    // is unreliable, then we don't want to add node to the resultArray.\n    util.fixFaultyLocations(node, lines);\n\n    if (resultArray) {\n        if (n.Node.check(node) &&\n            n.SourceLocation.check(node.loc)) {\n            // This reverse insertion sort almost always takes constant\n            // time because we almost always (maybe always?) append the\n            // nodes in order anyway.\n            for (var i = resultArray.length - 1; i >= 0; --i) {\n                if (comparePos(resultArray[i].loc.end,\n                               node.loc.start) <= 0) {\n                    break;\n                }\n            }\n            resultArray.splice(i + 1, 0, node);\n            return;\n        }\n    } else if (node[childNodesCacheKey]) {\n        return node[childNodesCacheKey];\n    }\n\n    var names;\n    if (isArray.check(node)) {\n        names = Object.keys(node);\n    } else if (isObject.check(node)) {\n        names = types.getFieldNames(node);\n    } else {\n        return;\n    }\n\n    if (!resultArray) {\n        Object.defineProperty(node, childNodesCacheKey, {\n            value: resultArray = [],\n            enumerable: false\n        });\n    }\n\n    for (var i = 0, nameCount = names.length; i < nameCount; ++i) {\n        getSortedChildNodes(node[names[i]], lines, resultArray);\n    }\n\n    return resultArray;\n}\n\n// As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\nfunction decorateComment(node, comment, lines) {\n    var childNodes = getSortedChildNodes(node, lines);\n\n    // Time to dust off the old binary search robes and wizard hat.\n    var left = 0, right = childNodes.length;\n    while (left < right) {\n        var middle = (left + right) >> 1;\n        var child = childNodes[middle];\n\n        if (comparePos(child.loc.start, comment.loc.start) <= 0 &&\n            comparePos(comment.loc.end, child.loc.end) <= 0) {\n            // The comment is completely contained by this child node.\n            decorateComment(comment.enclosingNode = child, comment, lines);\n            return; // Abandon the binary search at this level.\n        }\n\n        if (comparePos(child.loc.end, comment.loc.start) <= 0) {\n            // This child node falls completely before the comment.\n            // Because we will never consider this node or any nodes\n            // before it again, this node must be the closest preceding\n            // node we have encountered so far.\n            var precedingNode = child;\n            left = middle + 1;\n            continue;\n        }\n\n        if (comparePos(comment.loc.end, child.loc.start) <= 0) {\n            // This child node falls completely after the comment.\n            // Because we will never consider this node or any nodes after\n            // it again, this node must be the closest following node we\n            // have encountered so far.\n            var followingNode = child;\n            right = middle;\n            continue;\n        }\n\n        throw new Error(\"Comment location overlaps with node location\");\n    }\n\n    if (precedingNode) {\n        comment.precedingNode = precedingNode;\n    }\n\n    if (followingNode) {\n        comment.followingNode = followingNode;\n    }\n}\n\nexports.attach = function(comments, ast, lines) {\n    if (!isArray.check(comments)) {\n        return;\n    }\n\n    var tiesToBreak = [];\n\n    comments.forEach(function(comment) {\n        comment.loc.lines = lines;\n        decorateComment(ast, comment, lines);\n\n        var pn = comment.precedingNode;\n        var en = comment.enclosingNode;\n        var fn = comment.followingNode;\n\n        if (pn && fn) {\n            var tieCount = tiesToBreak.length;\n            if (tieCount > 0) {\n                var lastTie = tiesToBreak[tieCount - 1];\n\n                assert.strictEqual(\n                    lastTie.precedingNode === comment.precedingNode,\n                    lastTie.followingNode === comment.followingNode\n                );\n\n                if (lastTie.followingNode !== comment.followingNode) {\n                    breakTies(tiesToBreak, lines);\n                }\n            }\n\n            tiesToBreak.push(comment);\n\n        } else if (pn) {\n            // No contest: we have a trailing comment.\n            breakTies(tiesToBreak, lines);\n            addTrailingComment(pn, comment);\n\n        } else if (fn) {\n            // No contest: we have a leading comment.\n            breakTies(tiesToBreak, lines);\n            addLeadingComment(fn, comment);\n\n        } else if (en) {\n            // The enclosing node has no child nodes at all, so what we\n            // have here is a dangling comment, e.g. [/* crickets */].\n            breakTies(tiesToBreak, lines);\n            addDanglingComment(en, comment);\n\n        } else {\n            throw new Error(\"AST contains no nodes at all?\");\n        }\n    });\n\n    breakTies(tiesToBreak, lines);\n\n    comments.forEach(function(comment) {\n        // These node references were useful for breaking ties, but we\n        // don't need them anymore, and they create cycles in the AST that\n        // may lead to infinite recursion if we don't delete them here.\n        delete comment.precedingNode;\n        delete comment.enclosingNode;\n        delete comment.followingNode;\n    });\n};\n\nfunction breakTies(tiesToBreak, lines) {\n    var tieCount = tiesToBreak.length;\n    if (tieCount === 0) {\n        return;\n    }\n\n    var pn = tiesToBreak[0].precedingNode;\n    var fn = tiesToBreak[0].followingNode;\n    var gapEndPos = fn.loc.start;\n\n    // Iterate backwards through tiesToBreak, examining the gaps\n    // between the tied comments. In order to qualify as leading, a\n    // comment must be separated from fn by an unbroken series of\n    // whitespace-only gaps (or other comments).\n    for (var indexOfFirstLeadingComment = tieCount;\n         indexOfFirstLeadingComment > 0;\n         --indexOfFirstLeadingComment) {\n        var comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n        assert.strictEqual(comment.precedingNode, pn);\n        assert.strictEqual(comment.followingNode, fn);\n\n        var gap = lines.sliceString(comment.loc.end, gapEndPos);\n        if (/\\S/.test(gap)) {\n            // The gap string contained something other than whitespace.\n            break;\n        }\n\n        gapEndPos = comment.loc.start;\n    }\n\n    while (indexOfFirstLeadingComment <= tieCount &&\n           (comment = tiesToBreak[indexOfFirstLeadingComment]) &&\n           // If the comment is a //-style comment and indented more\n           // deeply than the node itself, reconsider it as trailing.\n           comment.type === \"Line\" &&\n           comment.loc.start.column > fn.loc.start.column) {\n        ++indexOfFirstLeadingComment;\n    }\n\n    tiesToBreak.forEach(function(comment, i) {\n        if (i < indexOfFirstLeadingComment) {\n            addTrailingComment(pn, comment);\n        } else {\n            addLeadingComment(fn, comment);\n        }\n    });\n\n    tiesToBreak.length = 0;\n}\n\nfunction addCommentHelper(node, comment) {\n    var comments = node.comments || (node.comments = []);\n    comments.push(comment);\n}\n\nfunction addLeadingComment(node, comment) {\n    comment.leading = true;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n}\n\nfunction addDanglingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n}\n\nfunction addTrailingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = true;\n    addCommentHelper(node, comment);\n}\n\nfunction printLeadingComment(commentPath, print) {\n    var comment = commentPath.getValue();\n    n.Comment.assert(comment);\n\n    var loc = comment.loc;\n    var lines = loc && loc.lines;\n    var parts = [print(commentPath)];\n\n    if (comment.trailing) {\n        // When we print trailing comments as leading comments, we don't\n        // want to bring any trailing spaces along.\n        parts.push(\"\\n\");\n\n    } else if (lines instanceof Lines) {\n        var trailingSpace = lines.slice(\n            loc.end,\n            lines.skipSpaces(loc.end)\n        );\n\n        if (trailingSpace.length === 1) {\n            // If the trailing space contains no newlines, then we want to\n            // preserve it exactly as we found it.\n            parts.push(trailingSpace);\n        } else {\n            // If the trailing space contains newlines, then replace it\n            // with just that many newlines, with all other spaces removed.\n            parts.push(new Array(trailingSpace.length).join(\"\\n\"));\n        }\n\n    } else {\n        parts.push(\"\\n\");\n    }\n\n    return concat(parts);\n}\n\nfunction printTrailingComment(commentPath, print) {\n    var comment = commentPath.getValue(commentPath);\n    n.Comment.assert(comment);\n\n    var loc = comment.loc;\n    var lines = loc && loc.lines;\n    var parts = [];\n\n    if (lines instanceof Lines) {\n        var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();\n        var leadingSpace = lines.slice(fromPos, loc.start);\n\n        if (leadingSpace.length === 1) {\n            // If the leading space contains no newlines, then we want to\n            // preserve it exactly as we found it.\n            parts.push(leadingSpace);\n        } else {\n            // If the leading space contains newlines, then replace it\n            // with just that many newlines, sans all other spaces.\n            parts.push(new Array(leadingSpace.length).join(\"\\n\"));\n        }\n    }\n\n    parts.push(print(commentPath));\n\n    return concat(parts);\n}\n\nexports.printComments = function(path, print) {\n    var value = path.getValue();\n    var innerLines = print(path);\n    var comments = n.Node.check(value) &&\n        types.getFieldValue(value, \"comments\");\n\n    if (!comments || comments.length === 0) {\n        return innerLines;\n    }\n\n    var leadingParts = [];\n    var trailingParts = [innerLines];\n\n    path.each(function(commentPath) {\n        var comment = commentPath.getValue();\n        var leading = types.getFieldValue(comment, \"leading\");\n        var trailing = types.getFieldValue(comment, \"trailing\");\n\n        if (leading || (trailing && comment.type !== \"Block\")) {\n            leadingParts.push(printLeadingComment(commentPath, print));\n        } else if (trailing) {\n            assert.strictEqual(comment.type, \"Block\");\n            trailingParts.push(printTrailingComment(commentPath, print));\n        }\n    }, \"comments\");\n\n    leadingParts.push.apply(leadingParts, trailingParts);\n    return concat(leadingParts);\n};\n"]}