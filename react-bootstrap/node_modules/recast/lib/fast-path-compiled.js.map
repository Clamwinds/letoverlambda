{"version":3,"sources":["fast-path.js"],"names":[],"mappings":"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","file":"fast-path-compiled.js","sourcesContent":["var assert = require(\"assert\");\nvar types = require(\"./types\");\nvar n = types.namedTypes;\nvar Node = n.Node;\nvar isArray = types.builtInTypes.array;\nvar isNumber = types.builtInTypes.number;\n\nfunction FastPath(value) {\n    assert.ok(this instanceof FastPath);\n    this.stack = [value];\n}\n\nvar FPp = FastPath.prototype;\nmodule.exports = FastPath;\n\n// Static convenience function for coercing a value to a FastPath.\nFastPath.from = function(obj) {\n    if (obj instanceof FastPath) {\n        // Return a defensive copy of any existing FastPath instances.\n        return obj.copy();\n    }\n\n    if (obj instanceof types.NodePath) {\n        // For backwards compatibility, unroll NodePath instances into\n        // lightweight FastPath [..., name, value] stacks.\n        var copy = Object.create(FastPath.prototype);\n        var stack = [obj.value];\n        for (var pp; (pp = obj.parentPath); obj = pp)\n            stack.push(obj.name, pp.value);\n        copy.stack = stack.reverse();\n        return copy;\n    }\n\n    // Otherwise use obj as the value of the new FastPath instance.\n    return new FastPath(obj);\n};\n\nFPp.copy = function copy() {\n    var copy = Object.create(FastPath.prototype);\n    copy.stack = this.stack.slice(0);\n    return copy;\n};\n\n// The name of the current property is always the penultimate element of\n// this.stack, and always a String.\nFPp.getName = function getName() {\n    var s = this.stack;\n    var len = s.length;\n    if (len > 1) {\n        return s[len - 2];\n    }\n    // Since the name is always a string, null is a safe sentinel value to\n    // return if we do not know the name of the (root) value.\n    return null;\n};\n\n// The value of the current property is always the final element of\n// this.stack.\nFPp.getValue = function getValue() {\n    var s = this.stack;\n    return s[s.length - 1];\n};\n\nfunction getNodeHelper(path, count) {\n    var s = path.stack;\n\n    for (var i = s.length - 1; i >= 0; i -= 2) {\n        var value = s[i];\n        if (n.Node.check(value) && --count < 0) {\n            return value;\n        }\n    }\n\n    return null;\n}\n\nFPp.getNode = function getNode(count) {\n    return getNodeHelper(this, ~~count);\n};\n\nFPp.getParentNode = function getParentNode(count) {\n    return getNodeHelper(this, ~~count + 1);\n};\n\n// The length of the stack can be either even or odd, depending on whether\n// or not we have a name for the root value. The difference between the\n// index of the root value and the index of the final value is always\n// even, though, which allows us to return the root value in constant time\n// (i.e. without iterating backwards through the stack).\nFPp.getRootValue = function getRootValue() {\n    var s = this.stack;\n    if (s.length % 2 === 0) {\n        return s[1];\n    }\n    return s[0];\n};\n\n// Temporarily push properties named by string arguments given after the\n// callback function onto this.stack, then call the callback with a\n// reference to this (modified) FastPath object. Note that the stack will\n// be restored to its original state after the callback is finished, so it\n// is probably a mistake to retain a reference to the path.\nFPp.call = function call(callback/*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n    var result = callback(this);\n    s.length = origLen;\n    return result;\n};\n\n// Similar to FastPath.prototype.call, except that the value obtained by\n// accessing this.getValue()[name1][name2]... should be array-like. The\n// callback will be called with a reference to this path object for each\n// element of the array.\nFPp.each = function each(callback/*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n\n    for (var i = 0; i < value.length; ++i) {\n        if (i in value) {\n            s.push(i, value[i]);\n            // If the callback needs to know the value of i, call\n            // path.getName(), assuming path is the parameter name.\n            callback(this);\n            s.length -= 2;\n        }\n    }\n\n    s.length = origLen;\n};\n\n// Similar to FastPath.prototype.each, except that the results of the\n// callback function invocations are stored in an array and returned at\n// the end of the iteration.\nFPp.map = function map(callback/*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n\n    var result = new Array(value.length);\n\n    for (var i = 0; i < value.length; ++i) {\n        if (i in value) {\n            s.push(i, value[i]);\n            result[i] = callback(this, i);\n            s.length -= 2;\n        }\n    }\n\n    s.length = origLen;\n\n    return result;\n};\n\n// Inspired by require(\"ast-types\").NodePath.prototype.needsParens, but\n// more efficient because we're iterating backwards through a stack.\nFPp.needsParens = function(assumeExpressionContext) {\n    var parent = this.getParentNode();\n    if (!parent) {\n        return false;\n    }\n\n    var name = this.getName();\n    var node = this.getNode();\n\n    // If the value of this path is some child of a Node and not a Node\n    // itself, then it doesn't need parentheses. Only Node objects (in\n    // fact, only Expression nodes) need parentheses.\n    if (this.getValue() !== node) {\n        return false;\n    }\n\n    // Only expressions need parentheses.\n    if (!n.Expression.check(node)) {\n        return false;\n    }\n\n    // Identifiers never need parentheses.\n    if (node.type === \"Identifier\") {\n        return false;\n    }\n\n    if (parent.type === \"ParenthesizedExpression\") {\n        return false;\n    }\n\n    switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n        return parent.type === \"MemberExpression\"\n            && name === \"object\"\n            && parent.object === node;\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n        switch (parent.type) {\n        case \"CallExpression\":\n            return name === \"callee\"\n                && parent.callee === node;\n\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n            return true;\n\n        case \"MemberExpression\":\n            return name === \"object\"\n                && parent.object === node;\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n            var po = parent.operator;\n            var pp = PRECEDENCE[po];\n            var no = node.operator;\n            var np = PRECEDENCE[no];\n\n            if (pp > np) {\n                return true;\n            }\n\n            if (pp === np && name === \"right\") {\n                assert.strictEqual(parent.right, node);\n                return true;\n            }\n\n        default:\n            return false;\n        }\n\n    case \"SequenceExpression\":\n        switch (parent.type) {\n        case \"ForStatement\":\n            // Although parentheses wouldn't hurt around sequence\n            // expressions in the head of for loops, traditional style\n            // dictates that e.g. i++, j++ should not be wrapped with\n            // parentheses.\n            return false;\n\n        case \"ExpressionStatement\":\n            return name !== \"expression\";\n\n        default:\n            // Otherwise err on the side of overparenthesization, adding\n            // explicit exceptions above if this proves overzealous.\n            return true;\n        }\n\n    case \"YieldExpression\":\n        switch (parent.type) {\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"CallExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n        case \"ConditionalExpression\":\n        case \"YieldExpression\":\n            return true;\n\n        default:\n            return false;\n        }\n\n    case \"Literal\":\n        return parent.type === \"MemberExpression\"\n            && isNumber.check(node.value)\n            && name === \"object\"\n            && parent.object === node;\n\n    case \"AssignmentExpression\":\n    case \"ConditionalExpression\":\n        switch (parent.type) {\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n            return true;\n\n        case \"CallExpression\":\n            return name === \"callee\"\n                && parent.callee === node;\n\n        case \"ConditionalExpression\":\n            return name === \"test\"\n                && parent.test === node;\n\n        case \"MemberExpression\":\n            return name === \"object\"\n                && parent.object === node;\n\n        default:\n            return false;\n        }\n\n    case \"ArrowFunctionExpression\":\n        return isBinary(parent);\n\n    case \"ObjectExpression\":\n        if (parent.type === \"ArrowFunctionExpression\" &&\n            name === \"body\") {\n            return true;\n        }\n\n    default:\n        if (parent.type === \"NewExpression\" &&\n            name === \"callee\" &&\n            parent.callee === node) {\n            return containsCallExpression(node);\n        }\n    }\n\n    if (assumeExpressionContext !== true &&\n        !this.canBeFirstInStatement() &&\n        this.firstInStatement())\n        return true;\n\n    return false;\n};\n\nfunction isBinary(node) {\n    return n.BinaryExpression.check(node)\n        || n.LogicalExpression.check(node);\n}\n\nfunction isUnaryLike(node) {\n    return n.UnaryExpression.check(node)\n        // I considered making SpreadElement and SpreadProperty subtypes\n        // of UnaryExpression, but they're not really Expression nodes.\n        || (n.SpreadElement && n.SpreadElement.check(node))\n        || (n.SpreadProperty && n.SpreadProperty.check(node));\n}\n\nvar PRECEDENCE = {};\n[[\"||\"],\n [\"&&\"],\n [\"|\"],\n [\"^\"],\n [\"&\"],\n [\"==\", \"===\", \"!=\", \"!==\"],\n [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n [\">>\", \"<<\", \">>>\"],\n [\"+\", \"-\"],\n [\"*\", \"/\", \"%\"]\n].forEach(function(tier, i) {\n    tier.forEach(function(op) {\n        PRECEDENCE[op] = i;\n    });\n});\n\nfunction containsCallExpression(node) {\n    if (n.CallExpression.check(node)) {\n        return true;\n    }\n\n    if (isArray.check(node)) {\n        return node.some(containsCallExpression);\n    }\n\n    if (n.Node.check(node)) {\n        return types.someField(node, function(name, child) {\n            return containsCallExpression(child);\n        });\n    }\n\n    return false;\n}\n\nFPp.canBeFirstInStatement = function() {\n    var node = this.getNode();\n    return !n.FunctionExpression.check(node)\n        && !n.ObjectExpression.check(node);\n};\n\nFPp.firstInStatement = function() {\n    var s = this.stack;\n    var parentName, parent;\n    var childName, child;\n\n    for (var i = s.length - 1; i >= 0; i -= 2) {\n        if (n.Node.check(s[i])) {\n            childName = parentName;\n            child = parent;\n            parentName = s[i - 1];\n            parent = s[i];\n        }\n\n        if (!parent || !child) {\n            continue;\n        }\n\n        if (n.BlockStatement.check(parent) &&\n            parentName === \"body\" &&\n            childName === 0) {\n            assert.strictEqual(parent.body[0], child);\n            return true;\n        }\n\n        if (n.ExpressionStatement.check(parent) &&\n            childName === \"expression\") {\n            assert.strictEqual(parent.expression, child);\n            return true;\n        }\n\n        if (n.SequenceExpression.check(parent) &&\n            parentName === \"expressions\" &&\n            childName === 0) {\n            assert.strictEqual(parent.expressions[0], child);\n            continue;\n        }\n\n        if (n.CallExpression.check(parent) &&\n            childName === \"callee\") {\n            assert.strictEqual(parent.callee, child);\n            continue;\n        }\n\n        if (n.MemberExpression.check(parent) &&\n            childName === \"object\") {\n            assert.strictEqual(parent.object, child);\n            continue;\n        }\n\n        if (n.ConditionalExpression.check(parent) &&\n            childName === \"test\") {\n            assert.strictEqual(parent.test, child);\n            continue;\n        }\n\n        if (isBinary(parent) &&\n            childName === \"left\") {\n            assert.strictEqual(parent.left, child);\n            continue;\n        }\n\n        if (n.UnaryExpression.check(parent) &&\n            !parent.prefix &&\n            childName === \"argument\") {\n            assert.strictEqual(parent.argument, child);\n            continue;\n        }\n\n        return false;\n    }\n\n    return true;\n};\n"]}